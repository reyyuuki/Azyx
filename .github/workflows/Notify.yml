name: Notify

on:
  workflow_run:
    workflows:
      - "Build and Release AzyX"
    types:
      - completed
  workflow_dispatch:
    inputs:
      previous_tag:
        description: 'Previous tag to compare against (optional, defaults to second most recent distinct tag)'
        required: false
      current_tag:
        description: 'Current tag to generate changelog for (optional, defaults to latest tag)'
        required: false

jobs:
  generate-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Check Job Statuses
        id: check_jobs
        env:
          WORKFLOW_RUN: ${{ toJSON(github.event.workflow_run) }}
          JOBS: ${{ toJSON(github.event.workflow_run.jobs) }}
        run: |
          echo "Workflow run event: $WORKFLOW_RUN"
          echo "Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Jobs data: $JOBS"

          if [ -z "$JOBS" ] || [ "$JOBS" == "null" ]; then
            echo "Warning: No job data available from workflow_run. Assuming failure unless manual trigger."
            ALL_SUCCESS=false
          else
            REQUIRED_JOBS=("build-windows" "build-ios" "build-macos" "build-android" "build-linux")
            SUCCESS_COUNT=0
            MINIMUM_SUCCESS=3  # Require at least 3 jobs to succeed

            for JOB in "${REQUIRED_JOBS[@]}"; do
              JOB_STATUS=$(echo "$JOBS" | jq -c ".[] | select(.name == \"$JOB\") | .conclusion")
              if [ "$JOB_STATUS" == '"success"' ]; then
                echo "Job $JOB succeeded. Status: $JOB_STATUS"
                ((SUCCESS_COUNT++))
              else
                echo "Job $JOB failed or was not found. Status: $JOB_STATUS"
              fi
            done

            if [ $SUCCESS_COUNT -ge $MINIMUM_SUCCESS ]; then
              echo "Sufficient jobs succeeded ($SUCCESS_COUNT/$MINIMUM_SUCCESS). Proceeding with changelog generation."
              echo "all_jobs_success=true" >> $GITHUB_OUTPUT
            else
              echo "Insufficient jobs succeeded ($SUCCESS_COUNT/$MINIMUM_SUCCESS). Skipping changelog generation unless manually triggered."
              echo "all_jobs_success=false" >> $GITHUB_OUTPUT
            fi
          fi
        shell: /usr/bin/bash -e {0}

      - name: Checkout Code
        uses: actions/checkout@v4
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        with:
          fetch-depth: 0

      - name: Clear CHANGELOG.md
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: echo "" > CHANGELOG.md

      - name: Fetch Tags
        id: fetch_tags
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          git fetch --tags
          TAGS=$(git tag --sort=-creatordate | tr '\n' ' ')
          echo "All tags: $TAGS"
          echo "tags=$TAGS" >> $GITHUB_ENV

      - name: Determine Tags for Comparison
        id: determine_tags
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          if [ -n "${{ inputs.current_tag }}" ]; then
            CURRENT_TAG="${{ inputs.current_tag }}"
          else
            CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$CURRENT_TAG" ]; then
              echo "Error: No tags found in repository."
              exit 1
            fi
          fi
          echo "Current tag: $CURRENT_TAG"
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_ENV

          ALL_TAGS=(${{ env.tags }})
          PREV_TAG=""
          SECOND_PREV_TAG=""

          for TAG in "${ALL_TAGS[@]}"; do
            if [ "$TAG" != "$CURRENT_TAG" ]; then
              if [ -z "$PREV_TAG" ]; then
                PREV_TAG="$TAG"
              elif [ -z "$SECOND_PREV_TAG" ]; then
                SECOND_PREV_TAG="$TAG"
                break
              fi
            fi
          done

          if [ -n "${{ inputs.previous_tag }}" ]; then
            PREV_TAG="${{ inputs.previous_tag }}"
          elif [ "$PREV_TAG" == "$CURRENT_TAG" ] || [ -z "$PREV_TAG" ]; then
            PREV_TAG="$SECOND_PREV_TAG"
          fi

          if [ -z "$PREV_TAG" ]; then
            PREV_TAG=$(git rev-list --max-parents=0 HEAD 2>/dev/null || echo "")
            if [ -z "$PREV_TAG" ]; then
              echo "Error: No previous tag or initial commit found."
              exit 1
            fi
          fi

          echo "Previous tag: $PREV_TAG"
          echo "prev_tag=$PREV_TAG" >> $GITHUB_ENV
        shell: /usr/bin/bash -e {0}

      - name: Debug Commit Log
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          echo "Commits between ${{ env.prev_tag }} and ${{ env.current_tag }}:"
          git log ${{ env.prev_tag }}..${{ env.current_tag }} --pretty=format:'%h %s' || echo "No commits found between tags."

      - name: Get Commit Messages Between Tags
        id: get_commits
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          git log ${{ env.prev_tag }}..${{ env.current_tag }} --pretty=format:'%h|||%s' > commits.tmp || echo "No commits found."
          echo "commits_file=commits.tmp" >> $GITHUB_OUTPUT
        shell: /usr/bin/bash -e {0}

      - name: Categorize Commits
        id: categorize
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          echo "Categorizing commits..."

          # Initialize section variables
          FEATURES=""
          BUG_FIXES=""
          REFACTORS=""
          STYLE_CHANGES=""
          PERFORMANCE=""
          CHORES=""

          # Get repository URL
          REPO_URL="https://github.com/${{ github.repository }}"

          # Process commits if file exists
          if [ -f commits.tmp ]; then
            while IFS='|||' read -r HASH MESSAGE; do
              [ -z "$HASH" ] && continue
              
              # Clean up the message
              CLEAN_MESSAGE=$(echo "$MESSAGE" | sed 's/#[0-9]\+//g' | sed 's/[^a-zA-Z0-9 .,:!-]//g' | tr '[:upper:]' '[:lower:]' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//')
              
              echo "Processing commit: $HASH - $CLEAN_MESSAGE"
              
              # Categorize based on message prefix
              if [[ "$MESSAGE" =~ ^feat: ]]; then
                DESCR=$(echo "$CLEAN_MESSAGE" | sed 's/^feat://')
                COMMIT_LINK="[÷ç]($REPO_URL/commit/$HASH)"
                FEATURES+="- $COMMIT_LINK $DESCR"$'\n'
              elif [[ "$MESSAGE" =~ ^fix:|^bug:|^improvement:|^patch: ]]; then
                DESCR=$(echo "$CLEAN_MESSAGE" | sed 's/^fix://' | sed 's/^bug://' | sed 's/^improvement://' | sed 's/^patch://')
                COMMIT_LINK="[÷ç]($REPO_URL/commit/$HASH)"
                BUG_FIXES+="- $COMMIT_LINK $DESCR"$'\n'
              elif [[ "$MESSAGE" =~ ^refactor: ]]; then
                DESCR=$(echo "$CLEAN_MESSAGE" | sed 's/^refactor://')
                COMMIT_LINK="[÷ç]($REPO_URL/commit/$HASH)"
                REFACTORS+="- $COMMIT_LINK $DESCR"$'\n'
              elif [[ "$MESSAGE" =~ ^style: ]]; then
                DESCR=$(echo "$CLEAN_MESSAGE" | sed 's/^style://')
                COMMIT_LINK="[÷ç]($REPO_URL/commit/$HASH)"
                STYLE_CHANGES+="- $COMMIT_LINK $DESCR"$'\n'
              elif [[ "$MESSAGE" =~ ^perf: ]]; then
                DESCR=$(echo "$CLEAN_MESSAGE" | sed 's/^perf://')
                COMMIT_LINK="[÷ç]($REPO_URL/commit/$HASH)"
                PERFORMANCE+="- $COMMIT_LINK $DESCR"$'\n'
              elif [[ "$MESSAGE" =~ ^chore:|^docs:|^build:|^ci: ]]; then
                DESCR=$(echo "$CLEAN_MESSAGE" | sed 's/^chore://' | sed 's/^docs://' | sed 's/^build://' | sed 's/^ci://')
                COMMIT_LINK="[÷ç]($REPO_URL/commit/$HASH)"
                CHORES+="- $COMMIT_LINK $DESCR"$'\n'
              fi
            done < commits.tmp
          else
            echo "No commits file found. Skipping categorization."
          fi

          # Generate changelog sections with date
          echo "## üÜï Changelog ($(date +'%Y-%m-%d'))" > CHANGELOG.md
          if [ -n "$FEATURES" ]; then
            echo -e "\n### üåü Features" >> CHANGELOG.md
            echo -e "$FEATURES" >> CHANGELOG.md
          fi
          if [ -n "$BUG_FIXES" ]; then
            echo -e "\n### üîß Bug Fixes & Improvements" >> CHANGELOG.md
            echo -e "$BUG_FIXES" >> CHANGELOG.md
          fi
          if [ -n "$REFACTORS" ]; then
            echo -e "\n### üîß Refactors" >> CHANGELOG.md
            echo -e "$REFACTORS" >> CHANGELOG.md
          fi
          if [ -n "$STYLE_CHANGES" ]; then
            echo -e "\n### üé® Style Changes" >> CHANGELOG.md
            echo -e "$STYLE_CHANGES" >> CHANGELOG.md
          fi
          if [ -n "$PERFORMANCE" ]; then
            echo -e "\n### üöÄ Performance Improvements" >> CHANGELOG.md
            echo -e "$PERFORMANCE" >> CHANGELOG.md
          fi
          if [ -n "$CHORES" ]; then
            echo -e "\n### üßπ Chores & Documentation" >> CHANGELOG.md
            echo -e "$CHORES" >> CHANGELOG.md
          fi

          # Add download badges
          CURRENT_TAG_SAFE=$(echo "${{ env.current_tag }}" | sed 's/[^a-zA-Z0-9.-]//g')
          echo -e "\n![Total Downloads](https://img.shields.io/github/downloads/reyyuuki/AzyX/total?style=for-the-badge&label=TOTAL%20DOWNLOADS&labelColor=black&color=white) ![Current Release](https://img.shields.io/github/downloads/reyyuuki/AzyX/${CURRENT_TAG_SAFE}/total?style=for-the-badge&label=CURRENT%20RELEASE&labelColor=black&color=white)" >> CHANGELOG.md
          
          # Clean up temporary file
          rm -f commits.tmp
        shell: /usr/bin/bash -e {0}

      - name: Debug CHANGELOG.md
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          echo "Contents of CHANGELOG.md:"
          cat CHANGELOG.md || echo "CHANGELOG.md is empty or not found."

      - name: Commit and Push Changelog
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        run: |
          git config --global user.name "Git Paneer"
          git config --global user.email "actions@github.com"
          git add CHANGELOG.md
          git commit --allow-empty -m "Update changelog for version ${{ env.current_tag }}"
          git push origin HEAD:main
        shell: /usr/bin/bash -e {0}

      - name: Create or Update Release
        if: ${{ steps.check_jobs.outputs.all_jobs_success == 'true' || github.event_name == 'workflow_dispatch' }}
        uses: ncipollo/release-action@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          bodyFile: CHANGELOG.md
          tag: ${{ env.current_tag }}
          allowUpdates: true